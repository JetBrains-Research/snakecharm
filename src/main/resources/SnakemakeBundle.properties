### Inspections: INSP ###
INSP.GROUP.snakemake=Snakemake

# SnakemakeResourcesUnnamedArgsInspection
INSP.NAME.resources.unnamed.args=Resources have to be named (e.g. 'threads=4').
INSP.INTN.name.argument=Name argument

# SnakemakeRuleRedeclarationInspection
INSP.NAME.rule.redeclaration=This rule name is already used by another rule declaration.
INSP.NAME.rule.redeclaration.possible=This rule name is probably used by another rule declaration. Not sure because this rule isn't at file top level.
INSP.INTN.rename.element=Rename element

# SnakemakeRuleSectionAfterExecutionInspection
INSP.NAME.rule.section.after.execution=No rule sections allowed after execution sections.
INSP.NAME.rule.section.after.execution.message=Rule section ''{0}'' isn''t allowed after ''{1}'' section.
INSP.INTN.move.execution.section.down.family=Move execution section to the end of the rule

# SnakemakeShadowSettingsInspection
INSP.NAME.shadow.settings=Shadow must either be 'shallow', 'full', 'minimal', or True (equivalent to 'full').
INSP.NAME.shadow.settings.full=The setting shadow: \"full\" fully shadows the entire subdirectory structure of the current workdir.
INSP.NAME.shadow.settings.minimal=The setting shadow: \"minimal\" only symlinks the inputs to the rule.
INSP.NAME.shadow.settings.shallow=By setting shadow: \"shallow\", the top level files and directories are symlinked, so that any relative paths in a subdirectory will be real paths in the filesystem.

# SmkSectionRedeclarationInspectoin
INSP.NAME.section.redeclaration=Section declaration above overrides this declaration
INSP.NAME.section.redeclaration.message=Declaration of section ''{0}'' above overrides this declaration.
INSP.INTN.remove.section.family=Remove section

# SmkSectionMultipleArgsInspection
INSP.NAME.section.multiple.args=Only one argument is allowed for this section.
INSP.NAME.section.multiple.args.message=Only one argument is allowed for ''{0}'' section.

# SmkSubworkflowRedeclarationInspection
INSP.NAME.subworkflow.redeclaration=Only last subworkflow with the same name will be executed

# SmkYetUndefinedNameInspection
INSP.NAME.rule.or.checkpoint.name.yet.undefined=Rule or Checkpoint name has not been defined yet
INSP.NAME.rule.or.checkpoint.name.yet.undefined.msg=Rule or Checkpoint name ''{0}'' has not been defined yet

# SmkLocalrulesRuleorderRepeatedRuleInspection
INSP.NAME.localrules.ruleorder.repeated.rule=This rule has already been added to this section.

# SmkLambdaRuleParamsInspection
INSP.NAME.only.specific.lambda.params=Only specific lambda params should be used in this section.
INSP.NAME.only.these.parameters.in.section=Only use ''{0}'' as lambda parameter in ''{1}'' section.
INSP.NAME.only.n.parameters.in.section=Don''t use more than {0} lambda parameter(s) in ''{1}'' section.
INSP.NAME.wildcards.first.parameter='wildcards' has to be the first lambda parameter.
INSP.NAME.wildcards.first.parameter.preferable=Snakemake documentation suggests it's preferable to name the first parameter 'wildcards'.
INSP.NAME.non.wildcards.param.first.parameter=''{0}'' cannot be the first lambda parameter in ''{1}'' section.
INSP.NAME.functions.not.allowed.in.section=Function object cannot be used as a value in ''{0}'' section.

# SmkWildcardNotDefinedInspection
INSP.NAME.wildcard.not.defined.title=Undefined wildcard usage.
INSP.NAME.wildcard.not.defined.in.section=Wildcard ''{0}'' isn''t defined in ''{1}'' section.
INSP.NAME.wildcard.not.defined=Wildcard ''{0}'' isn''t properly defined.
INSP.NAME.wildcard.not.defined.cannot.check=Cannot check whether wildcard ''{0}'' is defined or not.

# SmkNotSameWildcardsSetInspection
INSP.NAME.not.same.wildcards.set.title=Different wildcards sets used 'output', 'log' and 'benchmark' sections.
INSP.NAME.not.same.wildcards.set=Missing wildcards: {0}.

# SmkSLUnresolvedSectionInspection
INSP.NAME.unresolved.section.title=Unresolved rule or checkpoint section.
INSP.NAME.unresolved.section.message=Undeclared section usage: ''{0}''.

# SSmkSLMissingWildcardsAccessorPrefixInspection
INSP.NAME.wildcards.prefix.missing.title=Wildcard access requires 'wildcards.' prefix in this section.
INSP.NAME.wildcards.prefix.missing.message=Wildcard access requires 'wildcards.' prefix in this section.
INSP.INTN.add.wildcards.prefix=Add 'wildcards.' prefix.

# SmkSLSubscriptionIndexOutOfBoundsInspection
INSP.NAME.section.arg.idx.aiobe.title=Section argument index out of bounds.
INSP.NAME.section.arg.idx.aiobe.message=Section index is out of bounds: value should be in 0..{0}.
INSP.NAME.section.arg.idx.aiobe.zero.message=Section index is out of bounds. Only 0 is allowed here.

# SmkSLWildcardNameIsConfusingInspection
INSP.NAME.wildcards.confusing.name.title=Confusing wildcard name.
INSP.NAME.wildcards.confusing.name.like.section.message=Confusing wildcard name: ''{0}''. It looks like section name.
INSP.NAME.wildcards.confusing.name.with.dot.message=Confusing wildcard name: ''{0}'', looks like call chain. Please don''t use dots here.

### Annotators ###
ANN.keyword.argument.already.provided=Keyword argument already provided: {0}.
ANN.positional.argument.after.keyword.argument=Positional argument after keyword argument.
ANN.multiple.execution.sections=Multiple run/shell sections.


## Parsing
PARSE.expected.separator.message=''{0}'' expected
PARSE.expected.ruleorder=Expected a descending order of rule names, e.g. rule1 > rule2 > rule3 ...
PARSE.expected.localrules=Expected a comma separated list of rules that shall not be executed by the cluster command.
PARSE.expected.identifier=identifier expected
PARSE.expected.dedent=Dedent expected
PARSE.expected.indent=Indent expected
PARSE.incorrect.unindent=Unindent does not match any outer indentation level.
PARSE.eof.docstring=Docstring at end of file does not precede any statement

# String language parsing
SMKSL.PARSE.expected.identifier.name=Expected identifier name
SMKSL.PARSE.expected.regexp=Expected regular expression
SMKSL.PARSE.expected.rbrace=Expected '}'
SMKSL.PARSE.expected.rbracket=Expected ']'
SMKSL.PARSE.unexpected.character=Unexpected character
SMKSL.PARSE.expected.key=Expected key
SMKSL.PARSE.expected.comma=Expected ','
SMKSL.PARSE.expected.lbrace=Expected '{'

INSP.NAME.unresolved.subscription.ref=Unresolved key ''{0}''

# Types
TYPES.rule.section.type.text=rule section
TYPES.rule.wildcard.type.text=rule wildcard
